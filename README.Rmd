---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# workbch

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Travis build status](https://travis-ci.org/djnavarro/workbch.svg?branch=master)](https://travis-ci.org/djnavarro/workbch)
[![CRAN status](https://www.r-pkg.org/badges/version/workbch)](https://cran.r-project.org/package=workbch)
[![Codecov test coverage](https://codecov.io/gh/djnavarro/workbch/branch/master/graph/badge.svg)](https://codecov.io/gh/djnavarro/workbch?branch=master)
<!-- badges: end -->

The workbch package provides a "work bench" of tools for project management 
within R, based around the concept of a "job" (which might map to a single 
RStudio project or a single git repository). Jobs can be linked to multiple 
URLs, be associated with multiple "tasks", etc. In addition to basic tracking,
searching and filtering, the package provides some tools to navigate between
jobs, browse relevant websites, and check the git status of repositories linked
to a job. Priority levels and deadlines are supported for both jobs and tasks,
but financial information and time allocation is not.

## Installation

The workbch package has not been released on CRAN. You can install the
development version from [GitHub](https://github.com/) with:

``` r
# install.packages("remotes")
remotes::install_github("djnavarro/workbch")
```

The package is built from four families of functions:

- the `make_*` functions make jobs
- the `set_*` functions edit jobs, tasks, etc. 
- the `view_*` functions display information about jobs
- the `goto_*` functions navigate to projects and webpages
- the `delete_*` functions delete jobs, tasks, etc.

## Example 1: Getting started

The workbch package stores information in a few files that are stored
within a directory referred to as the "workbch home". The easiest way to set
this location in a persistent way is to edit the .Rprofile file to include
the following line:

```{r, eval = FALSE}
options(workbch.home = "PATH_TO_FOLDER")
```
```{r, include=FALSE}
# for the purposes of the demo, set the workbch home to a temp directory 
workbch::set_workbch_home(path = tempdir())
```

This ensures that whenever the workbch package is loaded it knows where to find information about jobs. Once this is done, you can start adding jobs! A "job" is intended to have roughly the same meaning as a "project" in everyday life (i.e., a self-contained body of work of some kind), but to avoid confusion with "RStudio projects" I've used a different term. Here's how to add and view the jobs you have stored:

```{r makejobs}
library(workbch)

view_jobs()

make_job(
  jobname = "workitout", 
  description = "sip martinis and party in France", 
  owner = "britney"
)

view_jobs()
```

Jobs can be deleted by name:

```{r deletejobs}
delete_job("workitout")
view_jobs()
```

## Example 2: People, owners and teams

The workbch package stores a data base of names and nicknames, so you can specify a person using their nickname instead of needing to type the full name:

```{r managepeople}
set_person("Beyonc√© Knowles", "beyonce")

set_person("Kelly Rowland", "kelly")

set_person("Michelle Williams", "michelle")

view_people()
```

Jobs can consist of multiple people on a *team* but the job must have a single *owner*, a named team member who is responsible for that job. When used in conjunction with nicknames, the `set_job()` function allows you to specify the team efficiently: 

```{r addbynickmame}
make_job(
  jobname = "survivor",
  description = "Run a survival analysis",
  owner = "beyonce",
  team = c("kelly", "michelle"),
  priority = 1,
  status = "inactive"
)
```

The owner of a job will automatically be added to the team. As before we can use `view_jobs()` to provide a summary of all listed jobs, which in this case is only a single job, but you can also use `view_job()` to look at a single job in more detail:

```{r viewjob}
view_jobs()

view_job("survivor")
```


## Example 3: Editing jobs

Internally, a job is represented as a list with the following fields

- `jobname`: name of the project
- `description`: brief description of the project
- `owner`: should be a name or a nickname
- `status`: should be "active", "inactive", "complete", "abandoned"
- `team`: should be a vector of names/nicknames (owner is automatically included)
- `priority`: numeric
- `deadline`: a date
- `path`: path to the project home directory
- `urls`: a tibble specifying urls linked to the job
- `tasks`: a tibble specifying tasks linked to the job 
- `notes`: a tibble specifying notes linked to the job

When we added the "survival" job earlier, we specified some of these fields but not others. There are a numver of functions you can use to modify the properties of a job:

- `set_jobname()` allows you to reset name, 
- `set_team()` makes it easier to edit the team
- `set_url()` makes it easier to edit a webpage associated with a job
- `set_note()`
- `set_task()`
- etc

To illustrate, suppose we make a new job, called "toxic":

```{r maketoxic}
set_person("Britney Spears", "britney")
set_person("Danielle Navarro", "danielle")

make_job(
  jobname = "toxic",
  description = "Estimate the LD50 dose",
  owner = "britney",
  priority = 2,
  status = "active",
  path = "~/projects/toxic"
)

view_jobs()

view_job("toxic")
```

If at this point we realise that "Danielle" should have been listed on the team for toxic (yeah, right) and the priority should have been set at 1, we can edit the job. Similarly, if we want to add some URLS:

```{r editteam}
set_priority("toxic", 1)
set_team("toxic", add = "danielle")
set_url("toxic", site = "github", link = "https://github.com/djnavarro/toxic")
set_url("toxic", site = "genius", link = "https://genius.com/Britney-spears-toxic-lyrics")

view_job("toxic")
```


## Example 4: Filtering and prioritising

After a while one can easily end up with a lot of jobs, and it can be hard to find what you're looking for (or, if you're like me, get anxious at seeing so many things that you have to do). For example:

```{r include=FALSE}
set_person("Sneaker Pimps", "sneaker")
set_person("Lizzo", "lizzo")
make_job("hitmebaby", "Signal detection modelling", "britney", priority = 2)
make_job("spinspinsugar", "Check for periodicities", "sneaker", priority = 1)
make_job("boys", "Distributional assumptions", "lizzo", priority = 2)
```
```{r busystate}
view_jobs()
```

A simple way to only see the high priority jobs:

```{r prioritise}
view_priorities()
```

More generally, `view_jobs()` and `view_priorities()` both allow you to pass filtering expressions to `dplyr::filter()` to extract the subset you're interested in. Suppose I only want to see the high priority active jobs:

```{r filtering}
view_jobs(priority == 1 & status == "active")
```

Indeed `view_priorities()` function is essentially a helper function to avoid having to type `view_jobs(priority == 1)` on a regular basis. 

## Example 5: Navigation

To open a webpage associated with a job, it is as simple as using the `goto_url()` function:

```{r eval=FALSE}
goto_url("toxic", "github")
```

To open the corresponding RStudio project (assuming that there is an RStudio project file located in the directory specified as the project path)...

```{r eval=FALSE}
goto_project("toxic")
```

If there is no RStudio project at the relevant location, or the RStudio API is not available (i.e., RStudio is not running), all this function will do is use `setwd()` to change the working directory.

## Example 6: Adding, viewing and deleting notes

Often it is handy to add small annotations to a job. The intent here is not to use this as a substitute for proper documentation but as a quick and dirty "notes to self" tool. You can add jobs using `set_note()`:

```{r addnotes}
set_note("toxic", "check if this worked")
set_note("toxic", "i wonder if i should circulate this later")
```

You can view the notes linked to a job with `view_notes()`:

```{r viewnotes}
view_notes("toxic")
```

The output is shown in chronological order (recent at the top). You can remove a note by referring to its number:

```{r deletenotes}
delete_note("toxic", 1)
view_notes("toxic")
```

As present the notes themselves do not show up directly when calling `view_job()`. Instead there is a counter that indicates that a job has notes associated with it:

```{r shownotesinjob}
view_job("toxic")
```


